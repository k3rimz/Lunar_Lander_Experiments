#####################
camera.py
#####################
import pygame

class Camera:
    def __init__(self, width, height):
        self.rect = pygame.Rect(0, 0, width, height)
        self.width = width
        self.height = height
        self.deadzone_left = int(width * 0.2)
        self.deadzone_right = int(width * 0.8)

    def update(self, target_pos, landscape):
        # Calculate target position relative to camera without wrapping
        rel_x = target_pos[0] - self.rect.left

        # Horizontal movement
        if rel_x < self.deadzone_left:
            self.rect.x += rel_x - self.deadzone_left
        elif rel_x > self.deadzone_right:
            self.rect.x += rel_x - self.deadzone_right

        # Vertical movement
        self.rect.centery = target_pos[1]

        # Ensure camera stays within vertical bounds
        if self.rect.top < 0:
            self.rect.top = 0
        elif self.rect.bottom > landscape.height:
            self.rect.bottom = landscape.height

        # Remove horizontal wrapping
        # self.rect.left = self.rect.left % landscape.width


#####################
consolidate_files.py
#####################
import os

def is_text_file(file_path, blocksize=512):
    """
    Determines if a file is a text file.
    Tries to read a block of the file and checks for decoding errors.
    """
    try:
        with open(file_path, 'rb') as file:
            block = file.read(blocksize)
            if b'\0' in block:
                return False
            # Try decoding to UTF-8
            block.decode('utf-8')
            return True
    except:
        return False

def consolidate_files(directory, output_file):
    """
    Consolidates all text files in the specified directory into a single text file.
    
    Args:
    - directory (str): Path to the directory containing the files.
    - output_file (str): Path to the output consolidated text file.
    """
    # Get a list of all files in the directory
    files = os.listdir(directory)
    
    # Sort files for consistent ordering
    files.sort()
    
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for filename in files:
            file_path = os.path.join(directory, filename)
            
            # Skip directories
            if os.path.isdir(file_path):
                continue
            
            # Check if the file is a text file
            if not is_text_file(file_path):
                print(f"Skipping non-text file: {filename}")
                continue
            
            # Write the header
            outfile.write(f"#####################\n{filename}\n#####################\n")
            
            # Read and write the file content
            try:
                with open(file_path, 'r', encoding='utf-8') as infile:
                    content = infile.read()
                    outfile.write(content + "\n\n")  # Add spacing between files
            except Exception as e:
                print(f"Error reading {filename}: {e}")
    
    print(f"All files have been consolidated into '{output_file}'.")

if __name__ == "__main__":
    import argparse

    # Set up command-line argument parsing
    parser = argparse.ArgumentParser(description="Consolidate all text files in a directory into a single text file.")
    parser.add_argument(
        "-d", "--directory",
        type=str,
        default=".",
        help="Path to the directory containing the files. Defaults to the current directory."
    )
    parser.add_argument(
        "-o", "--output",
        type=str,
        default="consolidated_files.txt",
        help="Name of the output file. Defaults to 'consolidated_files.txt'."
    )

    args = parser.parse_args()

    # Get absolute paths
    directory = os.path.abspath(args.directory)
    output_file = os.path.abspath(args.output)

    # Check if the directory exists
    if not os.path.isdir(directory):
        print(f"The directory '{directory}' does not exist.")
        exit(1)

    consolidate_files(directory, output_file)


#####################
game.py
#####################
# game.py
import pygame
import sys
from enum import Enum
from lander import Lander
from landscape import Landscape
from camera import Camera
from ui import Button
from utils import WINDOW_WIDTH, WINDOW_HEIGHT, FPS, update_window_size, world_to_screen

class GameState(Enum):
    MAIN_MENU = 1
    IN_GAME = 2
    LANDED_CRASHED = 3

def reset_game():
    global lander, camera
    lander = Lander([WINDOW_WIDTH / 2, 50], initial_fuel=1000)
    camera = Camera(WINDOW_WIDTH, WINDOW_HEIGHT)

def main():
    global score, start_time, lander, camera, landscape

    pygame.init()
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.RESIZABLE)
    clock = pygame.time.Clock()

    # Load assets after pygame.init()
    Lander.load_assets()

    score = 0
    start_time = pygame.time.get_ticks()

    lander = Lander([WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2], initial_fuel=1000)
    landscape = Landscape()
    camera = Camera(WINDOW_WIDTH, WINDOW_HEIGHT)

    current_game_state = GameState.MAIN_MENU

    running = True
    while running:
        if current_game_state == GameState.MAIN_MENU:
            current_game_state = handle_main_menu(screen)
        elif current_game_state == GameState.IN_GAME:
            current_game_state = handle_in_game(screen, clock)
        elif current_game_state == GameState.LANDED_CRASHED:
            current_game_state = handle_landed_crashed()

        if current_game_state is None:
            running = False

    pygame.quit()
    sys.exit()

def handle_main_menu(screen):
    start_button = Button(WINDOW_WIDTH/2 - 100, WINDOW_HEIGHT/2 - 40, 200, 80, 'Start')
    start_button.draw(screen, (0,0,0))
    pygame.display.update()
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return None
        if event.type == pygame.MOUSEBUTTONDOWN:
            if start_button.is_over(pygame.mouse.get_pos()):
                return GameState.IN_GAME
    
    return GameState.MAIN_MENU

def handle_in_game(screen, clock):
    global lander, camera, landscape

    screen.fill((0, 0, 0))

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            return None
        elif event.type == pygame.VIDEORESIZE:
            screen = update_window_size(event.w, event.h, screen, camera, lander, landscape)

    keys = pygame.key.get_pressed()
    if keys[pygame.K_LEFT]:
        lander.rotate_left()
    if keys[pygame.K_RIGHT]:
        lander.rotate_right()
    if keys[pygame.K_UP]:
        lander.apply_thrust()
    if keys[pygame.K_r]:
        reset_game()
    if keys[pygame.K_q]:
        return None

    lander.update_position(landscape.width, landscape.height)
    lander.update_rotation()
    camera.update(lander.position, landscape)

    landscape.render(screen, camera.rect)
    lander.draw(screen, camera, landscape)
    lander.draw_collision_box(screen, camera, landscape)
    lander.draw_metrics(screen, WINDOW_HEIGHT)

    font = pygame.font.SysFont("Arial", 18)
    fuel_text = font.render(f"Fuel: {lander.fuel}", True, (255, 255, 255))
    screen.blit(fuel_text, (10, 10))

    collision_result = lander.check_collision(landscape)
    if collision_result:
        print(collision_result)
        if collision_result in ['landed', 'crashed']:
            return GameState.LANDED_CRASHED

    pygame.display.flip()
    clock.tick(FPS)

    return GameState.IN_GAME

def handle_landed_crashed():
    pygame.time.delay(2000)  # 2-second pause
    reset_game()
    return GameState.IN_GAME

if __name__ == "__main__":
    main()


#####################
game_objects.py
#####################
import pygame
from utils import WINDOW_WIDTH, WINDOW_HEIGHT

class GameObstacle(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, obstacle_type, bonus_multiplier=1):
        super().__init__()
        self.rect = pygame.Rect(x, y, width, height)
        self.type = obstacle_type  # 'landing_pad' or 'terrain'
        self.bonus_multiplier = bonus_multiplier

    def update(self, new_width, new_height):
        # This method can be used to update the obstacle's position and size
        # if the window is resized or if we implement scrolling
        pass

    def draw(self, surface, camera):
        # This method can be implemented to draw the obstacle on the screen
        # taking into account the camera position
        pass

class LandingZone(GameObstacle):
    def __init__(self, x_ratio, y_ratio, width_ratio, height_ratio, bonus_multiplier=1):
        self.x_ratio = x_ratio
        self.y_ratio = y_ratio
        self.width_ratio = width_ratio
        self.height_ratio = height_ratio
        x = int(x_ratio * WINDOW_WIDTH)
        y = int(y_ratio * WINDOW_HEIGHT)
        width = int(width_ratio * WINDOW_WIDTH)
        height = int(height_ratio * WINDOW_HEIGHT)
        super().__init__(x, y, width, height, 'landing_pad', bonus_multiplier)

    def update(self, new_width, new_height):
        self.rect.x = int(self.x_ratio * new_width)
        self.rect.y = int(self.y_ratio * new_height)
        self.rect.width = int(self.width_ratio * new_width)
        self.rect.height = int(self.height_ratio * new_height)

# You can add more specific obstacle types here if needed in the future

#####################
lander.py
#####################
import pygame
import math
import os
from utils import world_to_screen
from pygame.math import Vector2

class Lander:
    lander_icon = None

    @classmethod
    def load_assets(cls):
        """Class method to load assets. Must be called after pygame.init()."""
        try:
            # Get the directory where this script is located
            script_dir = os.path.dirname(os.path.abspath(__file__))
            # Construct the path to the assets directory
            assets_dir = os.path.join(script_dir, '..', 'assets')
            # Construct the full path to the lander.png image
            lander_image_path = os.path.join(assets_dir, "lander.png")
            cls.lander_icon = pygame.image.load(lander_image_path).convert_alpha()
        except pygame.error as e:
            print(f"Unable to load lander image: {e}")
            pygame.quit()
            exit()

    def __init__(self, position, angle=0, gravity=0.02, thrust_power=0.04, initial_fuel=1000, init_landed=False, init_score_added=False):
        self.position = position
        self.angle = angle
        self.target_angle = angle
        self.velocity = [0, 0]
        self.size = 15
        self.gravity = gravity
        self.thrust_power = thrust_power
        self.fuel = initial_fuel
        self.last_rotation_time = 0
        self.rotation_delay = 150
        self.rotation_speed = 1.75  
        self.landed = init_landed
        self.score_added = init_score_added

    def rotate_left(self):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_rotation_time >= self.rotation_delay:
            self.target_angle = max(-90, self.target_angle - 15)
            self.last_rotation_time = current_time

    def rotate_right(self):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_rotation_time >= self.rotation_delay:
            self.target_angle = min(90, self.target_angle + 15)
            self.last_rotation_time = current_time

    def update_rotation(self):
        if self.angle != self.target_angle:
            if self.angle < self.target_angle:
                self.angle = min(self.angle + self.rotation_speed, self.target_angle)
            else:
                self.angle = max(self.angle - self.rotation_speed, self.target_angle)

    def apply_thrust(self):
        if self.fuel > 0:
            self.velocity[0] += math.sin(math.radians(self.angle)) * self.thrust_power
            self.velocity[1] -= math.cos(math.radians(self.angle)) * self.thrust_power
            self.fuel -= 1

    def update_position(self, landscape_width, landscape_height):
        if self.landed:
            return
        self.velocity[1] += self.gravity
        self.position[0] += self.velocity[0]
        self.position[1] += self.velocity[1]
        # Remove horizontal wrapping
        # self.position[0] = self.position[0] % landscape_width
        self.position[1] = max(0, min(self.position[1], landscape_height))


    def check_collision(self, landscape):
        lander_rect = pygame.Rect(self.position[0] - self.size, self.position[1] - self.size, self.size * 2, self.size * 2)

        for line in landscape.lines:
            line_start = Vector2(line.p1.x, line.p1.y)
            line_end = Vector2(line.p2.x, line.p2.y)
            if lander_rect.clipline(line_start.x, line_start.y, line_end.x, line_end.y):
                if line.landable and -5 <= self.angle <= 5 and abs(self.velocity[0]) <= 0.5 and abs(self.velocity[1]) <= 0.5:
                    return 'landed'
                else:
                    return 'crashed'
        return None


    def draw(self, surface, camera, landscape):
        screen_pos = world_to_screen(self.position, camera, landscape)
        rotated_icon = pygame.transform.rotate(Lander.lander_icon, -self.angle)
        icon_rect = rotated_icon.get_rect(center=screen_pos)
        surface.blit(rotated_icon, icon_rect)

    def draw_collision_box(self, surface, camera, landscape):
        points = [
            (self.position[0] + self.size * math.sin(math.radians(self.angle)), self.position[1] - self.size * math.cos(math.radians(self.angle))),
            (self.position[0] - self.size * math.sin(math.radians(self.angle + 120)), self.position[1] + self.size * math.cos(math.radians(self.angle + 120))),
            (self.position[0] - self.size * math.sin(math.radians(self.angle - 120)), self.position[1] + self.size * math.cos(math.radians(self.angle - 120))),
        ]
        adjusted_points = [world_to_screen(p, camera, landscape) for p in points]
        pygame.draw.polygon(surface, (255, 0, 0), adjusted_points, 2)

    def draw_metrics(self, surface, window_height):
        font = pygame.font.SysFont("Arial", 18)
        metrics = [
            f"Altitude: {int(window_height - self.position[1])}",
            f"Horizontal Speed: {int(self.velocity[0])}",
            f"Vertical Speed: {int(self.velocity[1])}",
            f"Fuel: {self.fuel}"
        ]
        for i, metric in enumerate(metrics):
            text = font.render(metric, True, (255, 255, 255))
            surface.blit(text, (10, 30 + i * 20))



#####################
landscape.py
#####################
import random
import pygame
import math

class Vector2:
    def __init__(self, x, y):
        self.x = x
        self.y = y

class LandscapeLine:
    def __init__(self, p1, p2):
        self.p1 = p1
        self.p2 = p2
        self.landable = (p1.y == p2.y)
        self.multiplier = 1

class LandingZone:
    def __init__(self, linenum, multi):
        self.lineNum = linenum
        self.multiplier = multi

class Landscape:
    def __init__(self):
        self.points = []
        self.lines = []
        self.stars = []
        self.availableZones = []
        self.zoneCombis = []
        self.currentCombi = 0
        self.zoneInfos = []
        self.landscale = 1.5
        self.flickerProgress = 0

        self.setupData()

        self.tileWidth = self.points[-1].x * self.landscale

        for p in self.points:
            p.x *= self.landscale
            p.y *= self.landscale
            p.y -= 50 * self.landscale

        for i in range(1, len(self.points)):
            p1 = self.points[i - 1]
            p2 = self.points[i]
            self.lines.append(LandscapeLine(p1, p2))

        for i in range(len(self.stars)):
            self.stars[i]['x'] *= self.landscale
            self.stars[i]['y'] *= self.landscale

        for line in self.lines:
            if random.random() < 0.1:
                star = {'x': line.p1.x, 'y': random.random() * 600}
                if star['y'] < line.p1.y and star['y'] < line.p2.y:
                    self.stars.append(star)

        # Calculate the total height of the landscape
        self.height = max(p.y for p in self.points)
        self.width = self.tileWidth  # Set width to tileWidth for a single tile

    def setupData(self):
        self.points.append(Vector2(0.5, 355.55))
        self.points.append(Vector2(5.45, 355.55))
        self.points.append(Vector2(6.45, 359.4))
        self.points.append(Vector2(11.15, 359.4))
        self.points.append(Vector2(12.1, 363.65))
        self.points.append(Vector2(14.6, 363.65))
        self.points.append(Vector2(15.95, 375.75))
        self.points.append(Vector2(19.25, 388))
        self.points.append(Vector2(19.25, 391.9))
        self.points.append(Vector2(21.65, 400))
        self.points.append(Vector2(28.85, 404.25))
        self.points.append(Vector2(30.7, 412.4))
        self.points.append(Vector2(33.05, 416.7))
        self.points.append(Vector2(37.9, 420.5))
        self.points.append(Vector2(42.7, 420.5))
        self.points.append(Vector2(47.4, 416.65))
        self.points.append(Vector2(51.75, 409.5))
        self.points.append(Vector2(56.55, 404.25))
        self.points.append(Vector2(61.3, 400))
        self.points.append(Vector2(63.65, 396.15))
        self.points.append(Vector2(68, 391.9))
        self.points.append(Vector2(70.3, 388))
        self.points.append(Vector2(75.1, 386.1))
        self.points.append(Vector2(79.85, 379.95))
        self.points.append(Vector2(84.7, 378.95))
        self.points.append(Vector2(89.05, 375.65))
        self.points.append(Vector2(93.75, 375.65))
        self.points.append(Vector2(98.5, 376.55))
        self.points.append(Vector2(103.2, 379.95))
        self.points.append(Vector2(104.3, 383.8))
        self.points.append(Vector2(107.55, 388))
        self.points.append(Vector2(108.95, 391.9))
        self.points.append(Vector2(112.4, 396.15))
        self.points.append(Vector2(113.3, 400))
        self.points.append(Vector2(117.1, 404.25))
        self.points.append(Vector2(121.95, 404.25))
        self.points.append(Vector2(125.3, 396.3))
        self.points.append(Vector2(128.6, 394.2))
        self.points.append(Vector2(132.45, 396.15))
        self.points.append(Vector2(135.75, 399.9))
        self.points.append(Vector2(138.15, 408.15))
        self.points.append(Vector2(144.7, 412.4))
        self.points.append(Vector2(146.3, 424.8))
        self.points.append(Vector2(149.55, 436.65))
        self.points.append(Vector2(149.55, 441.05))
        self.points.append(Vector2(154.35, 444.85))
        self.points.append(Vector2(163.45, 444.85))
        self.points.append(Vector2(168.15, 441.05))
        self.points.append(Vector2(172.95, 436.75))
        self.points.append(Vector2(175.45, 432.9))
        self.points.append(Vector2(179.7, 428.6))
        self.points.append(Vector2(181.95, 424.8))
        self.points.append(Vector2(186.7, 422.5))
        self.points.append(Vector2(189.15, 412.4))
        self.points.append(Vector2(191.55, 404.35))
        self.points.append(Vector2(196.35, 402.4))
        self.points.append(Vector2(200.7, 398.1))
        self.points.append(Vector2(205.45, 391.9))
        self.points.append(Vector2(210.15, 383.8))
        self.points.append(Vector2(212.55, 375.75))
        self.points.append(Vector2(216.85, 371.8))
        self.points.append(Vector2(219.3, 367.55))
        self.points.append(Vector2(220.65, 363.65))
        self.points.append(Vector2(224, 359.4))
        self.points.append(Vector2(228.8, 359.4))
        self.points.append(Vector2(233.55, 355.55))
        self.points.append(Vector2(237.85, 348.45))
        self.points.append(Vector2(242.65, 343.2))
        self.points.append(Vector2(245, 335.15))
        self.points.append(Vector2(247.35, 322.8))
        self.points.append(Vector2(247.3, 314.5))
        self.points.append(Vector2(248.35, 306.55))
        self.points.append(Vector2(252.2, 296.5))
        self.points.append(Vector2(256.55, 294.55))
        self.points.append(Vector2(257.95, 290.4))
        self.points.append(Vector2(261.25, 285.95))
        self.points.append(Vector2(265.95, 285.95))
        self.points.append(Vector2(267, 290.25))
        self.points.append(Vector2(271.75, 290.25))
        self.points.append(Vector2(273.25, 294.55))
        self.points.append(Vector2(275.2, 294.55))
        self.points.append(Vector2(278.95, 296.5))
        self.points.append(Vector2(282.25, 300.3))
        self.points.append(Vector2(284.7, 308.45))
        self.points.append(Vector2(291.85, 312.65))
        self.points.append(Vector2(298.55, 330.8))
        self.points.append(Vector2(303.25, 331.8))
        self.points.append(Vector2(308, 335.05))
        self.points.append(Vector2(309, 338.9))
        self.points.append(Vector2(312.35, 343.2))
        self.points.append(Vector2(313.8, 347.05))
        self.points.append(Vector2(317.05, 351.4))
        self.points.append(Vector2(321.9, 351.4))
        self.points.append(Vector2(322.85, 363.8))
        self.points.append(Vector2(326.6, 375.75))
        self.points.append(Vector2(326.6, 379.95))
        self.points.append(Vector2(330.9, 379.95))
        self.points.append(Vector2(332.4, 383.8))
        self.points.append(Vector2(335.8, 388))
        self.points.append(Vector2(338.1, 396.15))
        self.points.append(Vector2(340.45, 400.1))
        self.points.append(Vector2(345.3, 404.25))
        self.points.append(Vector2(346.25, 416.65))
        self.points.append(Vector2(349.6, 428.7))
        self.points.append(Vector2(349.6, 432.85))
        self.points.append(Vector2(350.95, 436.75))
        self.points.append(Vector2(354.3, 441.05))
        self.points.append(Vector2(359, 441.05))
        self.points.append(Vector2(361.4, 449.1))
        self.points.append(Vector2(363.95, 453))
        self.points.append(Vector2(368.2, 457.2))
        self.points.append(Vector2(372.9, 461))
        self.points.append(Vector2(410.2, 461))
        self.points.append(Vector2(412.55, 449.1))
        self.points.append(Vector2(417.4, 441.05))
        self.points.append(Vector2(419.7, 432.9))
        self.points.append(Vector2(422.05, 432.9))
        self.points.append(Vector2(425.45, 424.8))
        self.points.append(Vector2(428.8, 422.35))
        self.points.append(Vector2(433.45, 416.65))
        self.points.append(Vector2(438.25, 415.15))
        self.points.append(Vector2(442.6, 412.4))
        self.points.append(Vector2(447.4, 412.4))
        self.points.append(Vector2(448.8, 416.65))
        self.points.append(Vector2(454.55, 430.55))
        self.points.append(Vector2(455.5, 434.8))
        self.points.append(Vector2(459.25, 438.6))
        self.points.append(Vector2(462.6, 440.9))
        self.points.append(Vector2(466, 444.85))
        self.points.append(Vector2(468.35, 452.9))
        self.points.append(Vector2(475.55, 457.3))
        self.points.append(Vector2(484.7, 457.3))
        self.points.append(Vector2(494.7, 458.2))
        self.points.append(Vector2(503.75, 461.1))
        self.points.append(Vector2(522.2, 461.1))
        self.points.append(Vector2(524.75, 453))
        self.points.append(Vector2(527.1, 441.05))
        self.points.append(Vector2(527.1, 432.9))
        self.points.append(Vector2(531.9, 432.9))
        self.points.append(Vector2(534.15, 424.8))
        self.points.append(Vector2(538.6, 420.5))
        self.points.append(Vector2(540.9, 416.65))
        self.points.append(Vector2(542.35, 412.5))
        self.points.append(Vector2(545.7, 408))
        self.points.append(Vector2(550.45, 408))
        self.points.append(Vector2(552.85, 398.1))
        self.points.append(Vector2(554.75, 389.95))
        self.points.append(Vector2(559.55, 388))
        self.points.append(Vector2(564.35, 391.9))
        self.points.append(Vector2(573.35, 391.9))
        self.points.append(Vector2(578.1, 388))
        self.points.append(Vector2(579.55, 379.95))
        self.points.append(Vector2(582.9, 369.4))
        self.points.append(Vector2(587.75, 367.55))
        self.points.append(Vector2(588.65, 363.8))
        self.points.append(Vector2(592.05, 359.5))
        self.points.append(Vector2(596.85, 355.55))

        self.availableZones.append(LandingZone(0, 4))
        self.availableZones.append(LandingZone(13, 3))
        self.availableZones.append(LandingZone(25, 4))
        self.availableZones.append(LandingZone(34, 4))
        self.availableZones.append(LandingZone(63, 5))
        self.availableZones.append(LandingZone(75, 4))
        self.availableZones.append(LandingZone(106, 5))
        self.availableZones.append(LandingZone(111, 2))
        self.availableZones.append(LandingZone(121, 5))
        self.availableZones.append(LandingZone(133, 2))
        self.availableZones.append(LandingZone(148, 3))

        self.zoneCombis.append([2, 3, 7, 9])
        self.zoneCombis.append([7, 8, 9, 10])
        self.zoneCombis.append([2, 3, 7, 9])
        self.zoneCombis.append([1, 4, 7, 9])
        self.zoneCombis.append([0, 5, 7, 9])
        self.zoneCombis.append([6, 7, 8, 9])
        self.zoneCombis.append([1, 4, 7, 9])

    def render(self, surface, camera_rect):
        # Calculate how many tiles are needed to cover the screen
        tiles_needed = math.ceil(camera_rect.width / self.tileWidth) + 2

        # Calculate the starting tile index based on camera's left position
        start_tile = int(camera_rect.left // self.tileWidth) - 1

        for tile in range(start_tile, start_tile + tiles_needed):
            offset = tile * self.tileWidth

            # Render landscape lines
            for line in self.lines:
                start_pos = (line.p1.x + offset - camera_rect.left, line.p1.y - camera_rect.top)
                end_pos = (line.p2.x + offset - camera_rect.left, line.p2.y - camera_rect.top)
                color = (0, 255, 0) if line.landable else (255, 255, 255)
                pygame.draw.line(surface, color, start_pos, end_pos, 2)

            # Render stars
            for star in self.stars:
                star_pos = (star['x'] + offset - camera_rect.left, star['y'] - camera_rect.top)
                # Wrap stars horizontally
                star_pos = (star_pos[0] % camera_rect.width, star_pos[1])
                if 0 <= star_pos[0] < camera_rect.width and 0 <= star_pos[1] < camera_rect.height:
                    pygame.draw.circle(surface, (255, 255, 255), (int(star_pos[0]), int(star_pos[1])), 1)


#####################
ui.py
#####################
import pygame

class Button:
    def __init__(self, x, y, width, height, text=''):
        self.color = (0, 200, 0)  # Green
        self.x = x
        self.y = y
        self.width = width
        self.height = height
        self.text = text

    def draw(self, win, outline=None):
        if outline:
            pygame.draw.rect(win, outline, (self.x-2, self.y-2, self.width+4, self.height+4), 0)
        pygame.draw.rect(win, self.color, (self.x, self.y, self.width, self.height), 0)
        if self.text != '':
            font = pygame.font.SysFont('comicsans', 60)
            text = font.render(self.text, 1, (0,0,0))
            win.blit(text, (self.x + (self.width/2 - text.get_width()/2), self.y + (self.height/2 - text.get_height()/2)))

    def is_over(self, pos):
        return self.x < pos[0] < self.x + self.width and self.y < pos[1] < self.y + self.height

#####################
utils.py
#####################
import pygame

WINDOW_WIDTH = 1400
WINDOW_HEIGHT = 900
FPS = 120

BLUE = (0, 0, 122)
GREEN = (0, 255, 0)
BLACK = (0, 0, 0)

def world_to_screen(pos, camera, landscape):
    x = pos[0] - camera.rect.left
    y = pos[1] - camera.rect.top
    return (x, y)


def update_window_size(width, height, screen, camera, lander, landscape):
    global WINDOW_WIDTH, WINDOW_HEIGHT
    WINDOW_WIDTH = width
    WINDOW_HEIGHT = height
    screen = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT), pygame.RESIZABLE)
    
    # Update camera
    camera.width = WINDOW_WIDTH
    camera.height = WINDOW_HEIGHT
    camera.rect.width = WINDOW_WIDTH
    camera.rect.height = WINDOW_HEIGHT
    
    # Update camera position to keep lander in view
    camera.rect.center = lander.position
    
    # Ensure camera stays within vertical bounds
    camera.rect.top = max(0, min(camera.rect.top, landscape.height - camera.rect.height))
    # Remove horizontal wrapping
    # camera.rect.left = camera.rect.left % landscape.width  
    
    return screen



